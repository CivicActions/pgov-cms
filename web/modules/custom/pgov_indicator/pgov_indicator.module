<?php

/**
 * @file
 * Module hooks that affect Indicators and Measurements.
 */

use Drupal\pgov_indicator\Entity\Storage\Indicator;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\storage\Entity\StorageInterface;

/**
 * Implements hook_ENTITY_TYPE_load().
 *
 * Inspects all Indicator storage entities and ensures that its list of
 * related measurements appear in chronological order.
 */
function pgov_indicator_storage_load(array $entities): void {
  foreach ($entities as $entity) {

    if ($entity->bundle() == 'indicator' && $entity->hasField('field_measurements')) {
      $field = $entity->get('field_measurements');
      $values_original = $field->getValue();
      if ($values = $field->referencedEntities()) {
        // Sort the current value.
        usort($values, '_pgov_indicator_sort');

        // Re-set field values if the new deltas are in a different sequence.
        foreach ($values as $delta => $value) {
          if ($values_original[$delta]['target_id'] != $value->id()) {
            $field->set($delta, $value);
          }
        }
      }
    }
  }
}

/**
 * A callback for usort() that orders entities by date, based on field_period.
 */
function _pgov_indicator_sort($entity1, $entity2): int {
  if (_pgov_indicator_get_date($entity1) > _pgov_indicator_get_date($entity2)) {
    return 1;
  }
  return 0;
}

/**
 * Get the value of $entity->field_period->field_date_range, as a timestamp.
 *
 * @return int
 *   unix timestamp of the date range related to a measurement's time period.
 */
function _pgov_indicator_get_date($entity): int {
  if ($entity->hasField('field_period')) {
    $period = current($entity->get('field_period')->referencedEntities());
    if ($period && $period->hasField('field_date_range')) {
      $range = current($period->get('field_date_range')->getValue());
      if ($range) {
        return strtotime($range['end_value'] ?: $range['value']);
      }
    }
  }
  return 0;
}

/**
 * Implements hook_entity_bundle_info_alter().
 */
function pgov_indicator_entity_bundle_info_alter(array &$bundles): void {
  if (isset($bundles['storage']['indicator'])) {
    // phpcs:ignore Drupal.Classes.FullyQualifiedNamespace.UseStatementMissing
    $bundles['storage']['indicator']['class'] = \Drupal\pgov_indicator\Entity\Storage\Indicator::class;
  }
}

/**
 * Implements hook_entity_extra_field_info().
 */
function pgov_indicator_entity_extra_field_info() {
  $extra['storage']['indicator']['display']['measurements'] = [
    'label' => 'Measurement details for this indicator.',
    'visible' => FALSE,
  ];
  return $extra;
}

/**
 * Implements hook_entity_view().
 *
 * Crudely renders the field as a table so the data appears when the field is
 * enabled.
 *
 * @todo better handle theme/template if this gets real use.
 */
function pgov_indicator_storage_view(array &$build, StorageInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  if ($entity instanceof Indicator) {
    if ($display->getComponent('measurements')) {
      $measurements = $entity->getMeasurements($view_mode);
      $rows = [];
      foreach ($measurements['data'] as $measurement) {
        $rows[] =  [
          $measurement['name'],
          $measurement['target'],
          $measurement['value'],
        ];
      }
      $build['measurements'] = [
        '#theme' => 'table',
        '#header' => [t('Date'), t('Target'), t('Value')],
        '#rows' => $rows,
      ];
    }
  }
}
